import tkinter as tk
from tkinter import ttk, messagebox, filedialog, simpledialog
import sqlite3
import datetime
import requests
from maidenhead import to_location
from geopy.distance import geodesic

# Zmienna globalna dla Twojego lokatora
my_grid_square = "JO90qk"

# Funkcja ustawiająca ciemny motyw
def set_dark_mode(widget):
    widget.tk_setPalette(background='#2E2E2E', foreground='#FFFFFF', 
                         activeBackground='#3E3E3E', activeForeground='#FFFFFF',
                         highlightBackground='#3E3E3E', highlightColor='#FFFFFF',
                         insertBackground='#FFFFFF', selectBackground='#5E5E5E',
                         selectForeground='#FFFFFF', disabledForeground='#4E4E4E')

    style = ttk.Style()
    style.theme_use('clam')
    style.configure('TButton', background='#4E4E4E', foreground='#FFFFFF')
    style.map('TButton', background=[('active', '#5E5E5E')])
    style.configure('TLabel', background='#2E2E2E', foreground='#FFFFFF')
    style.configure('TEntry', fieldbackground='#3E3E3E', foreground='#FFFFFF')
    style.configure('TCombobox', fieldbackground='#3E3E3E', foreground='#FFFFFF')
    style.configure('Treeview', background='#3E3E3E', foreground='#FFFFFF', fieldbackground='#3E3E3E')
    style.configure('Treeview.Heading', background='#4E4E4E', foreground='#FFFFFF')

# Tworzenie bazy danych SQLite
def initialize_database():
    conn = sqlite3.connect("logbook.db")
    cursor = conn.cursor()
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS logbook (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        date_time TEXT,
        callsign TEXT,
        rst_sent TEXT,
        rst_received TEXT,
        band TEXT,
        mode TEXT,
        power TEXT,
        grid_square TEXT,
        distance REAL,
        name TEXT,
        country TEXT,
        comment TEXT
    )
    """)
    conn.commit()
    conn.close()

    # Dodanie kolumn 'grid_square' i 'distance' w przypadku istniejącej tabeli bez tych kolumn
    conn = sqlite3.connect("logbook.db")
    cursor = conn.cursor()
    cursor.execute("PRAGMA table_info(logbook)")
    columns = [col[1] for col in cursor.fetchall()]
    if "grid_square" not in columns:
        cursor.execute("ALTER TABLE logbook ADD COLUMN grid_square TEXT")
    if "distance" not in columns:
        cursor.execute("ALTER TABLE logbook ADD COLUMN distance REAL")
    conn.commit()
    conn.close()

# Funkcja do dodawania danych do bazy
def add_to_database(entry_data):
    conn = sqlite3.connect("logbook.db")
    cursor = conn.cursor()
    cursor.execute("""
    INSERT INTO logbook (date_time, callsign, rst_sent, rst_received, band, mode, power, grid_square, distance, name, country, comment)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, entry_data)
    conn.commit()
    conn.close()

# Funkcja do obliczania odległości między grid square
def calculate_distance(my_grid, their_grid):
    my_location = to_location(my_grid)
    their_location = to_location(their_grid)
    distance = geodesic(my_location, their_location).km
    return int(distance)

# Funkcja do usuwania danych z bazy
def delete_from_database(callsign):
    conn = sqlite3.connect("logbook.db")
    cursor = conn.cursor()
    cursor.execute("DELETE FROM logbook WHERE callsign = ?", (callsign,))
    conn.commit()
    conn.close()

# Funkcja eksportu do pliku ADIF (na razie szkielet)
def export_adif():
    conn = sqlite3.connect("logbook.db")
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM logbook")
    rows = cursor.fetchall()
    conn.close()
    
    adif_file = filedialog.asksaveasfilename(defaultextension=".adi", filetypes=[("ADIF Files", "*.adi")])
    if not adif_file:
        return
    
    with open(adif_file, "w") as f:
        f.write("Generated by Python Logger\n")
        for row in rows:
            f.write(f"<QSO_DATE:{len(row[1])}>{row[1]} <CALL:{len(row[2])}>{row[2]} <BAND:{len(row[4])}>{row[4]} <MODE:{len(row[5])}>{row[5]} <GRIDSQUARE:{len(row[8])}>{row[8]} <DISTANCE:{len(str(row[9]))}>{row[9]} km <COMMENT:{len(row[12])}>{row[12]} <EOR>\n")
    
    messagebox.showinfo("Eksport ADIF", f"Pomyślnie wyeksportowano do pliku: {adif_file}")

# Funkcja do pobierania danych z QRZ
def fetch_qrz_data(callsign):
    # Wprowadź swój klucz API QRZ tutaj
    api_key = "TWÓJ_KLUCZ_API_QRZ"
    url = f"https://api.qrz.com/xml?key={api_key}&callsign={callsign}"
    
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        return {
            "name": data.get("name"),
            "country": data.get("country")
        }
    else:
        messagebox.showerror("Błąd", "Nie udało się pobrać danych z QRZ")
        return None

# Funkcja do automatycznego wypełniania danych z QRZ
def auto_fill_qrz():
    callsign = callsign_entry.get()
    if not callsign:
        messagebox.showwarning("Ostrzeżenie", "Proszę wprowadzić znak wywoławczy")
        return

    data = fetch_qrz_data(callsign)
    if data:
        name_entry.delete(0, tk.END)
        name_entry.insert(0, data["name"])
        country_entry.delete(0, tk.END)
        country_entry.insert(0, data["country"])

# Funkcja do dodawania wpisów
def add_entry():
    their_grid = grid_square_entry.get()
    distance = calculate_distance(my_grid_square, their_grid)
    
    entry_data = (
        datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        callsign_entry.get(),
        rst_sent_entry.get(),
        rst_received_entry.get(),
        band_combobox.get(),
        mode_combobox.get(),
        power_entry.get(),
        grid_square_entry.get(),
        distance,
        name_entry.get(),
        country_entry.get(),
        comment_entry.get()
    )
    add_to_database(entry_data)
    update_table()
    clear_entries()
    messagebox.showinfo("Dodano", "QSO zostało dodane!")

# Funkcja do zmiany lokatora
def change_grid_square():
    global my_grid_square
    new_grid_square = simpledialog.askstring("Zmiana lokatora", "Wprowadź nowy lokator:", initialvalue=my_grid_square)
    if new_grid_square:
        my_grid_square = new_grid_square
        messagebox.showinfo("Zmieniono lokator", f"Twój lokator został zmieniony na: {my_grid_square}")

# Funkcja do usuwania wpisów
def delete_entry():
    selected_item = table.selection()
    if not selected_item:
        messagebox.showwarning("Ostrzeżenie", "Proszę zaznaczyć wpis do usunięcia")
        return

    callsign = table.item(selected_item)["values"][1]
    delete_from_database(callsign)
    table.delete(selected_item)
    messagebox.showinfo("Usunięto", "QSO zostało usunięte!")

# Czyszczenie pól
def clear_entries():
    callsign_entry.delete(0, tk.END)
    rst_sent_entry.delete(0, tk.END)
    rst_received_entry.delete(0, tk.END)
    power_entry.delete(0, tk.END)
    grid_square_entry.delete(0, tk.END)
    name_entry.delete(0, tk.END)
    country_entry.delete(0, tk.END)
    comment_entry.delete(0, tk.END)

# Aktualizacja tabeli
def update_table():
    for row in table.get_children():
        table.delete(row)
    
    conn = sqlite3.connect("logbook.db")
    cursor = conn.cursor()
    cursor.execute("SELECT date_time, callsign, rst_sent, rst_received, band, mode, power, grid_square, distance, name, country, comment FROM logbook")
    rows = cursor.fetchall()
    conn.close()

    for row in rows:
        table.insert("", tk.END, values=row)

# GUI aplikacji
root = tk.Tk()
root.title("Logger Krótkofalarski")

# Menu
menu = tk.Menu(root)
root.config(menu=menu)

settings_menu = tk.Menu(menu, tearoff=0)
menu.add_cascade(label="Ustawienia", menu=settings_menu)
settings_menu.add_command(label="Zmień lokator", command=change_grid_square)

# Ustawienie ciemnego motywu
set_dark_mode(root)

# Górna sekcja - formularz
form_frame = tk.Frame(root, padx=10, pady=10)
form_frame.pack(fill=tk.X)

tk.Label(form_frame, text="Znak wywoławczy").grid(row=0, column=0)
callsign_entry = tk.Entry(form_frame)
callsign_entry.grid(row=0, column=1)

tk.Label(form_frame, text="RST wysłane").grid(row=1, column=0)
rst_sent_entry = tk.Entry(form_frame)
rst_sent_entry.grid(row=1, column=1)
rst_sent_entry.insert(0, "59")  # Domyślna wartość

tk.Label(form_frame, text="RST odebrane").grid(row=2, column=0)
rst_received_entry = tk.Entry(form_frame)
rst_received_entry.grid(row=2, column=1)
rst_received_entry.insert(0, "59")  # Domyślna wartość

tk.Label(form_frame, text="Pasmo").grid(row=0, column=2)
band_combobox = ttk.Combobox(form_frame, values=["160m", "80m", "40m", "30m", "20m", "17m", "15m", "12m", "10m", "6m", "4m", "2m", "70cm"], state="readonly")
band_combobox.grid(row=0, column=3)

tk.Label(form_frame, text="Tryb").grid(row=1, column=2)
mode_combobox = ttk.Combobox(form_frame, values=["SSB", "CW", "DIGI", "FM"], state="readonly")
mode_combobox.grid(row=1, column=3)

tk.Label(form_frame, text="Moc (W)").grid(row=2, column=2)
power_entry = tk.Entry(form_frame)
power_entry.grid(row=2, column=3)

tk.Label(form_frame, text="Imię").grid(row=0, column=4)
name_entry = tk.Entry(form_frame)
name_entry.grid(row=0, column=5)

tk.Label(form_frame, text="Kraj").grid(row=1, column=4)
country_entry = tk.Entry(form_frame)
country_entry.grid(row=1, column=5)

tk.Label(form_frame, text="Grid Square").grid(row=2, column=4)
grid_square_entry = tk.Entry(form_frame)
grid_square_entry.grid(row=2, column=5)

tk.Label(form_frame, text="Komentarz").grid(row=3, column=4)
comment_entry = tk.Entry(form_frame)
comment_entry.grid(row=3, column=5)

tk.Button(form_frame, text="Dodaj QSO", command=add_entry).grid(row=4, column=0, columnspan=2, pady=10)
tk.Button(form_frame, text="Eksportuj ADIF", command=export_adif).grid(row=4, column=2, columnspan=2, pady=10)
tk.Button(form_frame, text="Auto-wypełnianie z QRZ", command=auto_fill_qrz).grid(row=4, column=4, columnspan=2, pady=10)
tk.Button(form_frame, text="Usuń QSO", command=delete_entry).grid(row=4, column=6, columnspan=2, pady=10)

# Dolna sekcja - tabela
table_frame = tk.Frame(root, padx=10, pady=10)
table_frame.pack(fill=tk.BOTH, expand=True)

columns = ("date_time", "callsign", "rst_sent", "rst_received", "band", "mode", "power", "grid_square", "distance", "name", "country", "comment")
table = ttk.Treeview(table_frame, columns=columns, show="headings")
table.pack(fill=tk.BOTH, expand=True)

for col in columns:
    table.heading(col, text=col.replace("_", " ").capitalize())
    table.column(col, width=100)

# Inicjalizacja
initialize_database()
update_table()

root.mainloop()
